# Haskell: ДЗ 2 -- Используем язык для создания практичного приложения.

Второе домашнее задание проверяет понимание основных языка, что используются в
производственном программированиии. Обратите внимание, что задание соответствует
материалу, который рассказан в темах со 5 по 7
[отсюда](https://github.com/jagajaga/FP-Course-ITMO).

К заданию требуется создать тесты.

Документация в формате [Haddock](https://www.haskell.org/haddock/) будет
являться значимым бонусом.

Если вы видите неоднозначность в формулировке домашнего задания, то, пожалуйста,
обратитесь к преподавателям по электронной почте или в официальном канале в
slack.

Задача оценивается в максимум 10 баллов + бонусы.

# Срок сдачи

00:00 (UTC+3) 9 Мая 2020.

## Файловый менеджер и облегченная система контроля версий

Необходимо реализовать программу для манипуляции файлами на языке Haskell
используя конструкции монадных трансформеров и используя возможности IO монады.
Любые техники, что выходят за рамки текущего курса, будут приветствоваться.

Файловый менеджер будет атомарным и иметь простой функционал
просмотра/создания/удаления файлов и папок. Система контроля версий будет
следить за каждым файлом по отдельности и уметь их объединять.

Важно работать с файловой системой в чистом виде. Необходимо изначально считать
текущее состояние директории, а затем, после всех манипуляций записать новое
измененное состояние ~сознания~ файловой системы. Начните имплементацию с
формализации типа описания файловой системы и ее компонентов, а так же типов
для команд. После завершения программы, результаты ее действия должны
существовать в вашей файловой системе и директориях, которыми вы манипулировали.

Обратите внимание на обработку ошибок. Крайне нежелательно использование IORef и
подобных техник.

Информацию и состояние ревизий можно хранить рядом с рабочей директорией.

Для работы с реальной файловой системой используйте библиотеку
[directory](https://hackage.haskell.org/package/directory-1.3.6.1),
для парсинга аргументов командной строки мы рекомендуем
[optparse-applicative](https://hackage.haskell.org/package/optparse-applicative).

Необходимый функционал:

* command line interface (возможна реализация в виде интерактивной коммандной строки);
* переходить по директориям;
* показывать содержимое текущей директории;
* создать папку/файл;
* отобразить содержимое файла;
* удалить папку/файл;
* записать в файл текстовую информацию;
* поиск файла по названию  в текущей директории и ее подчастях и вывод пути до файла;
* отображать информацию о заданном файле:
    * путь;
    * права доступа;
    * тип файла;
    * время создания и/или изменения;
    * размер;    
* отображать информацию о директории:
    * размер;
    * путь;
    * количество файлов внутри;
    * права доступа;
* возможность инициализации системы контроля версий (СКВ) в текущей директории;
    * если текущая директория является частью уже инициализированной в СКВ, то
    инициализация не требуется;
* добавление файла или папки (всех файлов внутрии нее) в СКВ;
* добавления измененной версии файла и автоматической создание новой ревизии
данного файла;
    * добавление комментария к изменению;
* просмотр истории изменений файла;
    * подразумевается просмотр упорядоченного списка ревизий с комментариями;
* вывод конкретной версии файла по индексу в истории его изменений;
* объединение разных ревизий одного файла;
    * выбор приоритетного файла для объединения в случае конфликта;
    * бонусом будет иметь интерактивное объединение файлов, где пользователь
    будет по каждому случаю выбирать приоритет;
* удалить ревизию файла;
* удалить файл из СКВ;
* просмотр упорядоченную историю изменений файлов в заданной директории и ее
поддиректориях.

Пример:

```
*Main> main
./testDir
.> help
Commands:
cd <folder>                                               -- change directory
cdmk <folder>                                             -- change directory recursively creating directories
ls                                                        -- show current directory content
mkdir 'folder_name'                                       -- create folder in the current directory
cat <file>                                                -- show file content
touch 'file_name'                                         -- create file in the current folder
rmdir <folder>                                            -- delete folder
rm <file>                                                 -- delete file
write <file> 'text'                                       -- write text into the file
find 'file'                                               -- find file in the current directory and subdirectories
fileInfo <file>                                           -- show information about the file
dirInfo <folder>                                          -- show information about the folder
vcs_init                                                  -- init VCS in the current directory
vcs_add <file|folder>                                     -- add file or folder in the VCS
vcs_update <file> 'message'                               -- update file in the VCS
vcs_hist <file>                                           -- show file changes history
vcs_cat <file> 'index'                                    -- show current file content
vcs_delete <file> 'index'                                 -- remove particular file version
vcs_remove <file>                                         -- remove file from the VCS
vcs_merge <file> <index1> <index2> <left | right | both>  -- merge files accoridng to merging policy given
vcs_all                                                   -- show all VCS history
help                                                      -- show help commands
exit                                                      -- turn off the FS and exit 
.> ls

.> mkdir A B C
.> ls
C
B
A

.> mkdir A/B/C
.> ls A
B

.> write a First text
.> cat a
First text
.> cd E_No_Folder
No directory in file system
.> mkdir D
.> ls
a
D
C
B
A

.> vcs_init
.> vcs_add a
.> write a a1a1a1a1a1
.> vcs_update a new changes
.> vcs_hist a
0. initial
1. new changes

.> vcs_cat a 0
First text
.> vcs_cat a 1
a1a1a1a1a1
.> vcs_merge a 0 1 both
.> cat a
First text
>>>>>>>>>>>>
a1a1a1a1a1
.> exit
```